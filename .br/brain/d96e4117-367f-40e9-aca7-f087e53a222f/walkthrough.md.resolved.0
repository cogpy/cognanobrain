# Phase 3 Walkthrough: PPM Implementation

## Summary

Implemented complete Phase Prime Metric (PPM) module for Chapter 3 of the NanoBrain C++ adaptation.

## Files Created

### [nanobrain_ppm.h](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h) (~340 lines)
PPM metric class definitions including:
- 10 [PPMMetric](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#125-138) classes (1-10)
- [PPMOperatorChain](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#325-351) for composition
- [PPMCoherenceTable](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#361-362) with 32K precomputed entries
- [PPMEvolution](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#396-397) for time crystal evolution

### [nanobrain_ppm.cpp](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.cpp) (~900 lines)
Full implementations with:
- Prime factorization ([OrderedFactor](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#47-53))
- Phase path calculation (golden ratio based)
- Prime lattice (twins/cousins/sexy primes)
- Imaginary layers (complex operations)
- Coherence table initialization

### [ppm_demo.cpp](file:///e:/antg/nanob/cognanobrain/src/cpp/ppm_demo.cpp) (~210 lines)
Demo program showcasing all PPM functionality.

---

## 10 PPM Metrics

| # | Class | Purpose |
|---|-------|---------|
| 1 | [PPMMetric1_GeometricShape](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#147-159) | Integer → GML shape via prime factors |
| 2 | [PPMMetric2_OrderedFactor](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#164-176) | Prime decomposition with ratio |
| 3 | [PPMMetric3_PhasePath](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#181-193) | 360° CW/CCW phase using φ |
| 4 | [PPMMetric4_DomainLimit](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#198-210) | Prime domain boundaries |
| 5 | [PPMMetric5_HighOrderedFactor](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#215-228) | High OF ratio detection |
| 6 | [PPMMetric6_HoleFinder](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#233-245) | Gap detection in primes |
| 7 | [PPMMetric7_PrimeStatistics](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#250-262) | Silent/active ratios |
| 8 | [PPMMetric8_PeriodicRipples](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#267-279) | Periodicity detection |
| 9 | [PPMMetric9_PrimeLattice](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#284-299) | Twin/cousin graph |
| 10 | [PPMMetric10_ImaginaryLayers](file:///e:/antg/nanob/cognanobrain/src/cpp/nanobrain_ppm.h#304-317) | Complex layer ops |

---

## Usage Example

```cpp
#include "nanobrain_ppm.h"

// Create metric chain
PPMOperatorChain chain;
chain.add_by_index(1);  // Geometric Shape
chain.add_by_index(3);  // Phase Path
chain.add_by_index(9);  // Prime Lattice

// Compute on primes
std::vector<int> primes = {2, 3, 5, 7, 11};
auto results = chain.execute(primes);

// Lookup coherence
PPMCoherenceTable table;
float coherence = table.lookup(primes);  // O(1)

// Evolve time crystal
PPMEvolution evolution(&kernel);
state = evolution.evolve(state, chain, 0.1f);
```

---

## Verification

To test the implementation:

```bash
cd build
./ppm_demo
```

Expected output:
- All 10 metrics compute successfully
- Coherence table has 32,767 entries
- Phase plot exports to `phase_plot.csv`

---

## Changes to CMakeLists.txt

```diff:CMakeLists.txt
cmake_minimum_required(VERSION 3.10)

project(NanoBrainKernel VERSION 1.0.0)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_CXX_EXTENSIONS OFF)

# ================================================================
# GGML / llama.cpp Configuration
# ================================================================

# Set GGML_PATH to the root of llama.cpp or ggml repo
if(NOT DEFINED GGML_PATH)
    message(STATUS "GGML_PATH not defined, assuming ./ggml")
    set(GGML_PATH "./ggml")
endif()

# Check for llama.cpp structure (ggml under llama.cpp)
if(EXISTS "${GGML_PATH}/ggml/include")
    # llama.cpp style (ggml as submodule)
    set(GGML_INCLUDE_DIRS 
        ${GGML_PATH}/ggml/include
        ${GGML_PATH}/ggml/src
        ${GGML_PATH}/include
    )
    set(GGML_LIB_NAME ggml)
elseif(EXISTS "${GGML_PATH}/include")
    # Standalone ggml
    set(GGML_INCLUDE_DIRS ${GGML_PATH}/include ${GGML_PATH})
    set(GGML_LIB_NAME ggml)
else()
    # Fallback: assume headers in root
    set(GGML_INCLUDE_DIRS ${GGML_PATH})
    set(GGML_LIB_NAME ggml)
endif()

include_directories(${GGML_INCLUDE_DIRS})
message(STATUS "GGML Include Dirs: ${GGML_INCLUDE_DIRS}")

# ================================================================
# NanoBrain Library Sources
# ================================================================
# Add the kernel library with all NanoBrain modules
add_library(nanobrain_kernel STATIC
    nanobrain_kernel.cpp
    nanobrain_encoder.cpp
    nanobrain_reasoning.cpp
    nanobrain_attention.cpp
    nanobrain_time_crystal.cpp
    nanobrain_metacognitive.cpp
)

set(NANOBRAIN_HEADERS
    nanobrain_kernel.h
    nanobrain_encoder.h
    nanobrain_types.h
    nanobrain_time_crystal.h
    nanobrain_reasoning.h
    nanobrain_attention.h
    nanobrain_metacognitive.h
)

# ================================================================
# Build Library Configuration
# ================================================================

target_include_directories(nanobrain_kernel PUBLIC 
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${GGML_INCLUDE_DIRS}
)

# Optional: Link against ggml if building as part of llama.cpp
# target_link_libraries(nanobrain_kernel PUBLIC ${GGML_LIB_NAME})

# ================================================================
# Test Executable
# ================================================================

add_executable(nanobrain_test main.cpp)
target_link_libraries(nanobrain_test nanobrain_kernel ${GGML_LIB_NAME})

# ================================================================
# Time Crystal Demo Executable
# ================================================================

add_executable(time_crystal_demo time_crystal_demo.cpp)
target_link_libraries(time_crystal_demo nanobrain_kernel ${GGML_LIB_NAME})

# ================================================================
# Compiler Warnings and Optimizations
# ================================================================

if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    target_compile_options(nanobrain_kernel PRIVATE 
        -Wall -Wextra -Wpedantic -Wno-unused-parameter
    )
    
    # Release optimizations
    if(CMAKE_BUILD_TYPE STREQUAL "Release")
        target_compile_options(nanobrain_kernel PRIVATE -O3 -march=native)
    endif()
elseif(MSVC)
    target_compile_options(nanobrain_kernel PRIVATE 
        /W4 /permissive- /wd4100
    )
    
    # Release optimizations
    if(CMAKE_BUILD_TYPE STREQUAL "Release")
        target_compile_options(nanobrain_kernel PRIVATE /O2)
    endif()
endif()

# ================================================================
# Installation Rules
# ================================================================

install(TARGETS nanobrain_kernel
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
)

install(FILES ${NANOBRAIN_HEADERS}
    DESTINATION include/nanobrain
)

# ================================================================
# Summary
# ================================================================

message(STATUS "")
message(STATUS "NanoBrain Kernel Configuration:")
message(STATUS "  - C++ Standard: C++${CMAKE_CXX_STANDARD}")
message(STATUS "  - GGML Path: ${GGML_PATH}")
message(STATUS "  - Build Type: ${CMAKE_BUILD_TYPE}")
message(STATUS "")
===
cmake_minimum_required(VERSION 3.10)

project(NanoBrainKernel VERSION 1.0.0)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)
set(CMAKE_CXX_EXTENSIONS OFF)

# ================================================================
# GGML / llama.cpp Configuration
# ================================================================

# Set GGML_PATH to the root of llama.cpp or ggml repo
if(NOT DEFINED GGML_PATH)
    message(STATUS "GGML_PATH not defined, assuming ./ggml")
    set(GGML_PATH "./ggml")
endif()

# Check for llama.cpp structure (ggml under llama.cpp)
if(EXISTS "${GGML_PATH}/ggml/include")
    # llama.cpp style (ggml as submodule)
    set(GGML_INCLUDE_DIRS 
        ${GGML_PATH}/ggml/include
        ${GGML_PATH}/ggml/src
        ${GGML_PATH}/include
    )
    set(GGML_LIB_NAME ggml)
elseif(EXISTS "${GGML_PATH}/include")
    # Standalone ggml
    set(GGML_INCLUDE_DIRS ${GGML_PATH}/include ${GGML_PATH})
    set(GGML_LIB_NAME ggml)
else()
    # Fallback: assume headers in root
    set(GGML_INCLUDE_DIRS ${GGML_PATH})
    set(GGML_LIB_NAME ggml)
endif()

include_directories(${GGML_INCLUDE_DIRS})
message(STATUS "GGML Include Dirs: ${GGML_INCLUDE_DIRS}")

# ================================================================
# NanoBrain Library Sources
# ================================================================
# Add the kernel library with all NanoBrain modules
add_library(nanobrain_kernel STATIC
    nanobrain_kernel.cpp
    nanobrain_encoder.cpp
    nanobrain_encoder_full.cpp
    nanobrain_reasoning.cpp
    nanobrain_attention.cpp
    nanobrain_time_crystal.cpp
    nanobrain_metacognitive.cpp
    nanobrain_unified.cpp
    nanobrain_atomese.cpp
    nanobrain_persistence.cpp
    nanobrain_serialization.cpp
    nanobrain_llm_bridge.cpp
    nanobrain_philosophical.cpp
    nanobrain_ppm.cpp
)

set(NANOBRAIN_HEADERS
    nanobrain_kernel.h
    nanobrain_encoder.h
    nanobrain_encoder_full.h
    nanobrain_types.h
    nanobrain_time_crystal.h
    nanobrain_reasoning.h
    nanobrain_attention.h
    nanobrain_metacognitive.h
    nanobrain_unified.h
    nanobrain_persistence.h
    nanobrain_serialization.h
    nanobrain_llm_bridge.h
    nanobrain_atomese.h
    nanobrain_philosophical.h
    nanobrain_ppm.h
)

# ================================================================
# Build Library Configuration
# ================================================================

target_include_directories(nanobrain_kernel PUBLIC 
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${GGML_INCLUDE_DIRS}
)

# Optional: Link against ggml if building as part of llama.cpp
# target_link_libraries(nanobrain_kernel PUBLIC ${GGML_LIB_NAME})

# ================================================================
# Test Executable
# ================================================================

add_executable(nanobrain_test main.cpp)
target_link_libraries(nanobrain_test nanobrain_kernel ${GGML_LIB_NAME})

# ================================================================
# Time Crystal Demo Executable
# ================================================================

add_executable(time_crystal_demo time_crystal_demo.cpp)
target_link_libraries(time_crystal_demo nanobrain_kernel ${GGML_LIB_NAME})

# ================================================================
# Unified Kernel Demo Executable
# ================================================================

add_executable(unified_demo unified_demo.cpp)
target_link_libraries(unified_demo nanobrain_kernel ${GGML_LIB_NAME})

# ================================================================
# PPM Demo Executable
# ================================================================

add_executable(ppm_demo ppm_demo.cpp)
target_link_libraries(ppm_demo nanobrain_kernel ${GGML_LIB_NAME})

# ================================================================
# Philosophical Transformation Demo (Chapter 1)
# ================================================================

add_executable(philosophical_demo philosophical_demo.cpp)
target_link_libraries(philosophical_demo nanobrain_kernel ${GGML_LIB_NAME})

# ================================================================
# Compiler Warnings and Optimizations
# ================================================================

if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    target_compile_options(nanobrain_kernel PRIVATE 
        -Wall -Wextra -Wpedantic -Wno-unused-parameter
    )
    
    # Release optimizations
    if(CMAKE_BUILD_TYPE STREQUAL "Release")
        target_compile_options(nanobrain_kernel PRIVATE -O3 -march=native)
    endif()
elseif(MSVC)
    target_compile_options(nanobrain_kernel PRIVATE 
        /W4 /permissive- /wd4100
    )
    
    # Release optimizations
    if(CMAKE_BUILD_TYPE STREQUAL "Release")
        target_compile_options(nanobrain_kernel PRIVATE /O2)
    endif()
endif()

# ================================================================
# Installation Rules
# ================================================================

install(TARGETS nanobrain_kernel
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
    RUNTIME DESTINATION bin
)

install(FILES ${NANOBRAIN_HEADERS}
    DESTINATION include/nanobrain
)

# ================================================================
# Summary
# ================================================================

message(STATUS "")
message(STATUS "NanoBrain Kernel Configuration:")
message(STATUS "  - C++ Standard: C++${CMAKE_CXX_STANDARD}")
message(STATUS "  - GGML Path: ${GGML_PATH}")
message(STATUS "  - Build Type: ${CMAKE_BUILD_TYPE}")
message(STATUS "")
```
